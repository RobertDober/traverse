
<!--
DO NOT EDIT THIS FILE
It has been generated from the template `README.md.eex` by Extractly (https://github.com/RobertDober/extractly.git)
and any changes you make in this file will most likely be lost
-->

![CI](https://github.com/RobertDober/traverse/workflows/CI/badge.svg)
[![Coverage Status](https://coveralls.io/repos/github/RobertDober/traverse/badge.svg?branch=master)](https://coveralls.io/github/RobertDober/traverse?branch=master)
[![Hex.pm](https://img.shields.io/hexpm/v/traverse.svg)](https://hex.pm/packages/traverse)
[![Hex.pm](https://img.shields.io/hexpm/dw/traverse.svg)](https://hex.pm/packages/traverse)
[![Hex.pm](https://img.shields.io/hexpm/dt/traverse.svg)](https://hex.pm/packages/traverse)
[![Inline docs](http://inch-ci.org/github/RobertDober/traverse.svg?branch=master)](http://inch-ci.org/github/RobertDober/traverse)

**N.B.**

This README contains the docstrings and doctests from the code by means of [extractly](https://hex.pm/packages/extractly)
and the following code examples are therefor verified with `ExUnit` doctests.

# Traverse... arbitrary Elixir Datastructures.

## Synopsis

`Traverse` exposes functions to, surprise, surprise, traverse arbitrary Elixir datastructures.

And with arbitrary datastructures we mean any combination of lists, maps, tuples and structs. 

## Overview

### Visitor and Reducer Pattern

Firstly there is `visit`, which implements the classic visitor pattern. It accepts a `visitor`,
which needs to implement `Traverse.VisitorBehavior` (this is not a typo but _en-us_ is my choice of language
and when _en-en_ is used it is by pure ignorance and YHS would be happy to be adverted of it)
Then `visit` traverses a given datastructure and invokes the function corresponding to each event.

E.g. given the following datastructure

```elixir
   visit([ {:a, %{k: 1}, :b} ], visitor)
```

 the following function invocations on `visitor` would happen

```elixir
   open_list, open_tuple, scalar(:a), open_map, open_tuple, scalar(:k), scalar(1), close_tuple, close_map, scalar(:b), close_tuple, close_list
```

Secondly there is `reduce` which implements a functional traversal. It accepts an intital accumulator and a reducer function which will be called
with an event, value tuple and the accumulator like so:

```elixir
   reduce([ {:a, %{k: 1}, :b} ], acc, reducer)
```

Will call reducer with the following values:

```elixir
    reducer {:open_list, nil}, acc -> acc1
    reducer {:open_tuple, nil}, acc1 -> acc2
    reducer {:scalar, :a}, acc2      -> acc3
    reducer {:open_map, nil}, acc3   -> acc4
    reducer {:open_tuple, ...
    reducer {:scalar, :k},...
    reducer {:scalar, 1}, ...
    reducer {:close_tuple, nil}, ...
    ...
```

These two _main_ functions are of course enough to implement any imaginable transformation of an arbitrary datastructure, however many
routinely useful transformations like mapping, flatmapping or filtering would need a lot of boiler plate code to be implemented in the
reducer or visitor all the time.

For this reason `Traverse` has done the work behind the scenes to expose these common patterns to simple _mapper_ or _filter_ functions

### Mapper Interface

We distinguish between three different types of mappers.

- Flat -> `flat_map`
- Structure Preserving Leaves Mapping (meaning scalar events) -> `map_leaves`
- Full Mapping on All Nodes -> `map_all`

While the `flat_map` function is actually trivial to implement with `reduce` its implementation is quite instructive

```elixir
  def flat_map(ds, mapper) do
    reduce(ds, [], fn {:scalar, value}, acc -> [mapper.(value)|acc,
                      _,                acc -> acc end)
    |> Enum.reverse
  end
```

`map_leaves` of course has to recreate the structure and cannot be sketched out like that, but here is what it does:

      iex(0)> map_leaves([{1, %{b: 2}, 3}],
      ...(0)>   fn n when is_number(n) -> n + 1,
      ...(0)>      x -> x end # needed as map keys are passed in 
      [{2, %{b: 3}, 4}]

There is a convenience version of `map_leaves` that is slower and might hide subtle errors as it wraps your mapper into
a function that catches `FunctionClauseError` exceptions and mimics the identity function.
Often, though, it is good enough

      iex(1)> map_leaves!([{1, %{b: 2}, 3}], fn n when is_number(n) -> n + 1 end)
      [{2, %{b: 3}, 4}]

However this contrived example is just a bad use case, as e.g. it would not catch non numeric scalar values that are,
allegedly not expected, that is why actually the option `ignore_keys: true` should have been passed in:

      iex(0)> map_leaves([{1, %{b: 2}, 3}], &(&1+1), ignore_keys: true)
      [{2, %{b: 3}, 4}]

This option concerns maps **and** structs.


## Author

Copyright Â© 2016,7,8,9, 2020,1 Robert Dober
robert.dober@gmail.com

# LICENSE

Same as Elixir, which is Apache License v2.0. Please refer to [LICENSE](LICENSE) for details.

SPDX-License-Identifier: Apache-2.0

